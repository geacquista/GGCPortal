{"ast":null,"code":"// import { createSlice } from '@reduxjs/toolkit';\n\n// // fetch the orders to update createAsyncThunk, ?\n\n// // Declaring the initial state to define the structure\n// const initialState = {\n//   // actually, get initial state from the database\n//   activeOrders: 0,\n//   activeInvoices: 0,\n//   ordersPlaced: 0,\n//   ordersProcessed: 0,\n//   ordersShipped: 0,\n//   missingInvoices: 0,\n//   unpaidInvoices: 0,\n\n//   // here, for the purposes of this as a state, do i need to have inactiveOrders??\n//   // should i use a flag in the order slice to use the counters\n//   // or keep this slice\n\n// };\n\n// // Creating a slice of the quickstats data defines the state and actions on that data\n// export const quickStats = createSlice({\n//   name: 'quickstats',\n//   initialState,\n//   reducers: {\n\n// \t//INSTEAD WE JUST FETCH FROM THE DB\n// \t// // Called by order -- iif(currentOrder.status === 'PLACED')\n// \t// addActiveOrder: (data) => {\n// \t// \tdata.activeOrders += 1;\n// \t// },\n// \t// // or should subActiveOrder be set inactive?\n// \t// subActiveOrder: (data) => {\n// \t// \tdata.activeOrders -= 1;\n// \t// },\n\n// \t// // Called by order -- if !order.invoice.isPaid\n// \t// addActiveInvoice: (data) => {\n// \t// \tdata.activeInvoices += 1;\n// \t// },\n// \t// // or should subActiveInvoice be +1 inactive invoice?\n// \t// subActiveInvoice: (data) => {\n// \t// \tdata.activeInvoices -= 1;\n// \t// },\n\n// \t// // Called by order -- if(currentOrder.status === 'PLACED')\n// \t// addOrderPlaced: (data) => {\n// \t// \tdata.ordersPlaced += 1;\n// \t// },\n// \t// subOrderPlaced: (data) => {\n// \t// \tdata.ordersPlaced -= 1;\n// \t// },\n\n// \t// // Called by order -- if !order.invoice.isPaid\n// \t// addOrderProcessed: (data) => {\n// \t// \tdata.ordersProcessed += 1;\n// \t// },\n// \t// subOrderProcessed: (data) => {\n// \t// \tdata.ordersProcessed -= 1;\n// \t// },\n\n// \t// // Called by order -- if !order.invoice.isPaid\n// \t// addOrderShipped: (data) => {\n// \t// \tdata.ordersShipped += 1;\n// \t// },\n// \t// subOrderShipped: (data) => {\n// \t// \tdata.ordersShipped -= 1;\n// \t// },\n\n// \t// // Called by order -- if order.invoice === null\n// \t// addMissingInvoice: (data) => {\n// \t// \tdata.missingInvoices += 1;\n// \t// },\n// \t// subMissingInvoice: (data) => {\n// \t// \tdata.missingInvoices -= 1;\n// \t// },\n\n// \t// // Called by order -- if !order.invoice.isPaid\n// \t// addUnpaidInvoice: (data) => {\n// \t// \tdata.unpaidInvoices += 1;\n// \t// },\n// \t// subUnpaidInvoice: (data) => {\n// \t// \tdata.unpaidInvoices -= 1;\n// \t// },\n//   },\n// });\n\n// // exporting the actions that can be called elsewhere\n// // export const { increment, decrement, incrementByAmount } = quickStats.actions;\n\n// // This is how we get the value from the store.\n// export const selectActiveOrders = (state) => state.quickstats.activeOrders; \t\t// Get active orders\n// export const selectActiveInvoices = (state) => state.quickstats.activeInvoices;\t\t// Active invoices\n// export const selectOrdersPlaced = (state) => state.quickstats.ordersPlaced;\t\t\t// Get orders placed\n// export const selectOrdersProcessed = (state) => state.quickstats.ordersProcessed;\t// Get orders processed\n// export const selectOrdersShipped = (state) => state.quickstats.ordersShipped;\t\t// Get orders shipped\n// export const selectMissingInvoices = (state) => state.quickstats.missingInvoices;\t// Get missing invoices\n// export const selectUnpaidInvoices = (state) => state.quickstats.unpaidInvoices;\t\t// Get unpaid invoices\n\n// // Exporting the reducer to be configured in ./store.js\n// export default quickStats.reducer;\n\n// // const getQuickStatsData = () => {\n// \t\t//where API code could go\n// \t// \tvar data = {\n// \t// \t\tactiveOrders: 0,\n// \t// \t\tactiveInvoices: 0,\n// \t// \t\tordersPlaced: 0,\n// \t// \t\tordersProcessed: 0,\n// \t// \t\tordersShipped: 0,\n// \t// \t\tmissingInvoices: 0,\n// \t// \t\tunpaidInvoices: 0,\n// \t// \t}\n\n// \t// \tfor(var i = 0; i < orders.length; i++){\n// \t// \t\tvar currentOrder = orders[i];\n// \t// \t\tif(currentOrder.status === 'PLACED'){\n// \t// \t\t\tdata.ordersPlaced++\n// \t// \t\t\tdata.activeOrders++\n\n// \t// \t\t} else if(currentOrder.status === 'PROCESSED'){\n// \t// \t\t\tdata.ordersProcessed++\n// \t// \t\t\tdata.activeOrders++\n\n// \t// \t\t} else if(currentOrder.status === 'SHIPPED'){\n// \t// \t\t\tdata.ordersShipped++\n// \t// \t\t\tdata.activeOrders++\n// \t// \t\t} \n\n// \t// \t\tif(currentOrder.invoice === null){\n// \t// \t\t\tdata.missingInvoices++\n\n// \t// \t\t} else if(!currentOrder.invoice.isPaid){\n// \t// \t\t\tdata.unpaidInvoices++\n\n// \t// \t\t}\n// \t// \t}\n\n// \t// \treturn data\n// \t// }","map":{"version":3,"names":[],"sources":["/Users/gabrielleacquista/Documents/GitHub/GGCPortal/frontend_goats_portal/src/store/stats_slice.js"],"sourcesContent":["// import { createSlice } from '@reduxjs/toolkit';\n\n\n// // fetch the orders to update createAsyncThunk, ?\n\n// // Declaring the initial state to define the structure\n// const initialState = {\n//   // actually, get initial state from the database\n//   activeOrders: 0,\n//   activeInvoices: 0,\n//   ordersPlaced: 0,\n//   ordersProcessed: 0,\n//   ordersShipped: 0,\n//   missingInvoices: 0,\n//   unpaidInvoices: 0,\n\n//   // here, for the purposes of this as a state, do i need to have inactiveOrders??\n//   // should i use a flag in the order slice to use the counters\n//   // or keep this slice\n\n// };\n\n// // Creating a slice of the quickstats data defines the state and actions on that data\n// export const quickStats = createSlice({\n//   name: 'quickstats',\n//   initialState,\n//   reducers: {\n\n// \t//INSTEAD WE JUST FETCH FROM THE DB\n// \t// // Called by order -- iif(currentOrder.status === 'PLACED')\n// \t// addActiveOrder: (data) => {\n// \t// \tdata.activeOrders += 1;\n// \t// },\n// \t// // or should subActiveOrder be set inactive?\n// \t// subActiveOrder: (data) => {\n// \t// \tdata.activeOrders -= 1;\n// \t// },\n\n// \t// // Called by order -- if !order.invoice.isPaid\n// \t// addActiveInvoice: (data) => {\n// \t// \tdata.activeInvoices += 1;\n// \t// },\n// \t// // or should subActiveInvoice be +1 inactive invoice?\n// \t// subActiveInvoice: (data) => {\n// \t// \tdata.activeInvoices -= 1;\n// \t// },\n\n// \t// // Called by order -- if(currentOrder.status === 'PLACED')\n// \t// addOrderPlaced: (data) => {\n// \t// \tdata.ordersPlaced += 1;\n// \t// },\n// \t// subOrderPlaced: (data) => {\n// \t// \tdata.ordersPlaced -= 1;\n// \t// },\n\n// \t// // Called by order -- if !order.invoice.isPaid\n// \t// addOrderProcessed: (data) => {\n// \t// \tdata.ordersProcessed += 1;\n// \t// },\n// \t// subOrderProcessed: (data) => {\n// \t// \tdata.ordersProcessed -= 1;\n// \t// },\n\t\n// \t// // Called by order -- if !order.invoice.isPaid\n// \t// addOrderShipped: (data) => {\n// \t// \tdata.ordersShipped += 1;\n// \t// },\n// \t// subOrderShipped: (data) => {\n// \t// \tdata.ordersShipped -= 1;\n// \t// },\n\n// \t// // Called by order -- if order.invoice === null\n// \t// addMissingInvoice: (data) => {\n// \t// \tdata.missingInvoices += 1;\n// \t// },\n// \t// subMissingInvoice: (data) => {\n// \t// \tdata.missingInvoices -= 1;\n// \t// },\n\n// \t// // Called by order -- if !order.invoice.isPaid\n// \t// addUnpaidInvoice: (data) => {\n// \t// \tdata.unpaidInvoices += 1;\n// \t// },\n// \t// subUnpaidInvoice: (data) => {\n// \t// \tdata.unpaidInvoices -= 1;\n// \t// },\n//   },\n// });\n\n// // exporting the actions that can be called elsewhere\n// // export const { increment, decrement, incrementByAmount } = quickStats.actions;\n\n// // This is how we get the value from the store.\n// export const selectActiveOrders = (state) => state.quickstats.activeOrders; \t\t// Get active orders\n// export const selectActiveInvoices = (state) => state.quickstats.activeInvoices;\t\t// Active invoices\n// export const selectOrdersPlaced = (state) => state.quickstats.ordersPlaced;\t\t\t// Get orders placed\n// export const selectOrdersProcessed = (state) => state.quickstats.ordersProcessed;\t// Get orders processed\n// export const selectOrdersShipped = (state) => state.quickstats.ordersShipped;\t\t// Get orders shipped\n// export const selectMissingInvoices = (state) => state.quickstats.missingInvoices;\t// Get missing invoices\n// export const selectUnpaidInvoices = (state) => state.quickstats.unpaidInvoices;\t\t// Get unpaid invoices\n\n\n// // Exporting the reducer to be configured in ./store.js\n// export default quickStats.reducer;\n\n// // const getQuickStatsData = () => {\n// \t\t//where API code could go\n// \t// \tvar data = {\n// \t// \t\tactiveOrders: 0,\n// \t// \t\tactiveInvoices: 0,\n// \t// \t\tordersPlaced: 0,\n// \t// \t\tordersProcessed: 0,\n// \t// \t\tordersShipped: 0,\n// \t// \t\tmissingInvoices: 0,\n// \t// \t\tunpaidInvoices: 0,\n// \t// \t}\n\n// \t// \tfor(var i = 0; i < orders.length; i++){\n// \t// \t\tvar currentOrder = orders[i];\n// \t// \t\tif(currentOrder.status === 'PLACED'){\n// \t// \t\t\tdata.ordersPlaced++\n// \t// \t\t\tdata.activeOrders++\n\n// \t// \t\t} else if(currentOrder.status === 'PROCESSED'){\n// \t// \t\t\tdata.ordersProcessed++\n// \t// \t\t\tdata.activeOrders++\n\n// \t// \t\t} else if(currentOrder.status === 'SHIPPED'){\n// \t// \t\t\tdata.ordersShipped++\n// \t// \t\t\tdata.activeOrders++\n// \t// \t\t} \n\n// \t// \t\tif(currentOrder.invoice === null){\n// \t// \t\t\tdata.missingInvoices++\n\n// \t// \t\t} else if(!currentOrder.invoice.isPaid){\n// \t// \t\t\tdata.unpaidInvoices++\n\t\t\t\t\t\n// \t// \t\t}\n// \t// \t}\n\n// \t// \treturn data\n// \t// }\n"],"mappings":"AAAA;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA"},"metadata":{},"sourceType":"module"}