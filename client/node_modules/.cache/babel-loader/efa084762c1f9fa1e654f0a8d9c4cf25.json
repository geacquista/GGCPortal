{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n  return _typeof(obj);\n}\nimport { matchPath } from \"react-router\";\nvar createSelectors = function createSelectors(structure) {\n  var getIn = structure.getIn,\n    toJS = structure.toJS;\n  var isRouter = function isRouter(value) {\n    return value != null && _typeof(value) === 'object' && getIn(value, ['location']) && getIn(value, ['action']);\n  };\n  var getRouter = function getRouter(state) {\n    var router = toJS(getIn(state, ['router']));\n    if (!isRouter(router)) {\n      throw 'Could not find router reducer in state tree, it must be mounted under \"router\"';\n    }\n    return router;\n  };\n  var getLocation = function getLocation(state) {\n    return toJS(getIn(getRouter(state), ['location']));\n  };\n  var getAction = function getAction(state) {\n    return toJS(getIn(getRouter(state), ['action']));\n  };\n  var getSearch = function getSearch(state) {\n    return toJS(getIn(getRouter(state), ['location', 'search']));\n  };\n  var getHash = function getHash(state) {\n    return toJS(getIn(getRouter(state), ['location', 'hash']));\n  }; // It only makes sense to recalculate the `matchPath` whenever the pathname\n  // of the location changes. That's why `createMatchSelector` memoizes\n  // the latest result based on the location's pathname.\n\n  var createMatchSelector = function createMatchSelector(path) {\n    var lastPathname = null;\n    var lastMatch = null;\n    return function (state) {\n      var _ref = getLocation(state) || {},\n        pathname = _ref.pathname;\n      if (pathname === lastPathname) {\n        return lastMatch;\n      }\n      lastPathname = pathname;\n      var match = matchPath(pathname, path);\n      if (!match || !lastMatch || match.url !== lastMatch.url // When URL matched for nested routes, URL is the same but isExact is not.\n      || match.isExact !== lastMatch.isExact) {\n        lastMatch = match;\n      }\n      return lastMatch;\n    };\n  };\n  return {\n    getLocation: getLocation,\n    getAction: getAction,\n    getRouter: getRouter,\n    getSearch: getSearch,\n    getHash: getHash,\n    createMatchSelector: createMatchSelector\n  };\n};\nexport default createSelectors;","map":null,"metadata":{},"sourceType":"module"}